# =============================================================================
# Código de grupo: SI-05
# Estudiantes: Ander Arguiñano, Aitor Ugarte
# Entrega: Entrega 1
# Fecha: 28/02/2018
# =============================================================================

# =============================================================================
# INICIALIZACION DEL PROBLEMA
# Esta funcion devuelve una lista con los datos que formulan el problema. Al
# menos debe contener: state_initial, actions, name. Puedes añadir mas datos.
# La funcion debe contener un parametro de entrada con el nombre del fichero
# .CSV que contiene el estado inicial.

initialize_problem = function(file) {
  # Lista que contiene los datos del problema
  problem <- list()
  
  # Leemos el estado inicial del fichero
  estadoInicial <- read.csv(file, header=FALSE, sep=",")
  # Convertimos el data.frame obtenido en matriz
  problem$state_initial <- data.matrix(estadoInicial)
  # Eliminamos los nombres de las columnas
  colnames(problem$state_initial) <- NULL
  
  # Definimos las acciones del problema (color un 1, colocar un 2 y etc)
  problem$actions <- data.frame(action=c("Colocar1", "Colocar2", "Colocar3",
                                         "Colocar4", "Colocar5", "Colocar6",
                                         "Colocar7", "Colocar8", "Colocar9"),
                                          cost=1)

  # Definimos las columnas y las filas del problema
  problem$rows <- 9
  problem$columns <- 9
  
  # Establecemos el nombre del problema
  problem$name <- "Juego del Sudoku" 
  
  return(problem)
}

# =============================================================================
# FUNCION IS_APPLICABLE
# Esta función recibe un estado, una acción y el problema. Devuelve TRUE si el
# la acción se puede aplicar sobre el estado y FALSE en caso contrario.

is_applicable = function(state, action, problem) {
  
  # Obtenemos el nombre de la acción que se desea ejecutar
  action <- action$action
  
  # Buscamos el primer hueco libre
  where <- buscar_hueco(state)
  
  linea <- where[1] # Fila en la que está el 0
  columna <- where[1, 2] # Columna en la que está el 0
 
  # Comprobamos si la acción se puede llevar a cabo
  result <- comprobar_numero (state, as.integer(substr(action, 8, 9)),
                              linea, columna)

  return(result)
}

# =============================================================================
# EL EFECTO DE LA ACCION
# Esta función recibe un estado y una acción. Devuelve el estado resultante de
# aplicar la acción sobre el estado.

effect = function(state, action) {

  # Obtenemos el nombre de la acción
  action <- action$action
  
  # Buscamos el primer hueco libre
  where <- buscar_hueco(state)
  
  linea <- where[1]  # Fila en la que está el 0
  columna <- where[1, 2]  # Columna en la que está el 0
  
  # El nuevo estado que se genera al colocar el número
  state_new <- state

  # Colocamos el número en la posición determinada
  state_new[linea, columna] <- as.integer(substr(action, 8, 9))

  return(state_new)
}

# =============================================================================
# COMPROBACION DE ESTADO FINAL
# Esta función recibe un estado y el estado final. Devuelve el resultado de la
# comparación de los dos estados. Si el problema a resolver no tiene un
# estado final, se puede omitir el segundo parámetro.
# Comprueba si hay algún cero, devuelve TRUE si no hay y FALSE si sí hay.

is_final_state = function(state, final_state) {
  #Comprobamos si queda algún cero en el sudoku
  return(sum(state == 0) == 0)
}


# =============================================================================
# FUNCION TO_STRING
# Esta función recibe un estado como parámetro y muestra su contenido en la
# consola de una forma legible.

to_string = function(state) {
  
  #Muestra linea por linea la matriz del sudoku tomando un determinado estado
  for (i in 1:nrow(state)) {
    print(state[i,])
  }
  
}

# =============================================================================
# FUNCION PARA OBTENER EL COSTE
# Devuelve el coste de una determinada acción

get_cost = function(action, state) {
   return(action$cost)
}

# =============================================================================
# FUNCION PARA COMPROBAR QUE EL NUMERO SE PUEDE COLOCAR EN ESA POSICION
# Devuelve un booleano dependiendo de si el numero se puede colocar en esa 
# posicion o no 

comprobar_numero = function(state, numero, fila, columna) {
  # Comprobamos que en la fila y en la columna no exista ya ese número
  if (sum(state [fila,] == numero) == 0 && sum(state [,columna] == numero) == 0){
    if(fila%%3 == 1){ # Fila = 1
      a <- 1
      b <- 2
      if(columna%%3 == 1){ # Columna = 1
        c <- 1
        d <- 2
      } else if (columna%%3 == 2){ # Columna = 2
        c <- -1
        d <- 1
      } else{ # Columna = 3
        c <- -2
        d <- -1
      }
    } else if(fila%%3 == 2){ # Fila = 2
      a <- -1
      b <- 1
      if(columna%%3 == 1){ # Columna = 1
        c <- 1
        d <- 2
      } else if (columna%%3 == 2){ # Columna = 2
        c <- -1
        d <- 1
      } else{ # Columna = 3
        c <- -2
        d <- -1
      }
    } else { # fila = 3
      a <- -2
      b <- -1
      if(columna%%3 == 1){ # Columna = 1
        c <- 1
        d <- 2
      } else if (columna%%3 == 2){ # Columna = 2
        c <- -1
        d <- 1
      } else{ # Columna = 3
        c <- -2
        d <- -1
      }
    }
    return(sum(state[c(fila+a, fila+b), c(columna+c, columna+d)]==numero)==0)
  }else{
    return (FALSE)
  }
}

# =============================================================================
# FUNCION PARA BUSCAR LOS 0'S EN EL SUDOKU
# Devuelve una matriz con las posiciones de los 0 en una determinada fila 
buscar_hueco = function(state) {
  
  # Vector con el num de 0's por línea
  huecosLinea <-apply(state,1,function(x) sum(x==0))
  # Vector con el num de 0's por columna
  huecosColumna<-apply(state,2,function(x) sum(x==0))
  # El número mínimo de 0's de la línea que los tiene
  minimoLinea <- min(huecosLinea[which(huecosLinea > 0)])
  # El número mínimo de 0's de la columna que los tiene
  minimoColumna <- min(huecosColumna[which(huecosColumna > 0)])

  # Si el mínimo de 0's es menor en las líneas que en las columnas..
  if(minimoLinea<minimoColumna){
    # Número de lineas que tienen el número mínimo de 0's
    numeroLinea <- which(huecosLinea==minimoLinea)
    # Matriz que contentrá las coordenadas de los 0's 
    posicion <- matrix(numeroLinea[1],sum(state[numeroLinea[1],]==0),2)
    # Colocamos en la columa 2, el número de columna en el que están los 0's
    posicion[,2] <- which(state[numeroLinea[1],]==0)
    
    }else{
      numeroColumna <- which(huecosColumna==minimoColumna)
      posicion <- matrix(numeroColumna[1],sum(state[,numeroColumna[1]]==0),2)
      posicion[,1] <- which(state[,numeroColumna[1]]==0)

    }
  
  # Devolvemos las coordenadas de los 0's en una determinada fila
  return(posicion)

}